# Java Concurrent

## Concurrent Basic

### 为什么要使用多线程（补充：协程）

任何一项技术的出现都是为了解决现有问题。

- **串行**：初期的计算机智能串行执行任务，并且需要长时间等待用户输入；
- **批处理**：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行；
- **进程**：进程独占内存空间，保存各自运行状态，相互间互不干扰且可以互相切换，为并发处理任务提供了可能；
- **线程**：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使得进程内的子任务得以并发执行
- **协程**：？？？

### 进程和线程的区别

**进程是资源分配的最小单位，线程是 CPU 调度的最小单位**

- 所有与进程相关的资源，都被记录在 PCB 中

- 进程是抢占处理机的调度单位；线程属于某个进程，共享其资源

  ![进程-PCB](https://blog-figure-bed.oss-cn-shanghai.aliyuncs.com/2020/08/2020-10-20-141221.png)

- 线程只由堆栈寄存器、程序计数器和 TCB 组成

  ![线程结构](https://blog-figure-bed.oss-cn-shanghai.aliyuncs.com/2020/08/2020-10-20-141333.png)

【总结】

- 线程不能看做独立应用，而进程可看做独立应用程序
- 进程有独立的内存地址空间，相互不影响，线程只是进程的不同执行路径
- 线程没有独立的内存地址空间，多进程的程序比多线程程序更健壮
- 进程的切换比线程的切换开销大

## Concurrent Principal

### synchronized 关键字底层原理

monitor - jvm 指令：monitor:enter 、 monitor:exit

synchronized 一般会用作线程之间的同步控制，它可以对类和对象进行加锁，依赖底层的 JVM 指令，线程在执行被修饰的代码块时会先执行 monitorenter 指令，退出时执行 monitorexit 指令，在执行被修饰的方法时，底层是根据是否设置了 ACC_synchronized 访问标志，ACC_synchronized 会去隐式调用两个指令：monitorenter 和 monitorexit。执行效果是一样的，只是体现的形式不一样。 执行过程就是每个对象都会关联一个 monitor，它里面有一个计数器，初始是0，如果有线程要获取 monitor 的锁，会先看计数器是不是0，如果是0说明没有线程在获取锁，那这个线程就可以获取 lock 锁，然后对计数器加1，如果不为0，判断线程是不是自己，是的话就重入锁，计数器+1，如果不是的话线程会陷入 block 阻塞状态。线程执行完代码退出后，底层会执行 monitorexit 指令，这个时候对应的monitor 计数器会减1，如果是多次重入锁,那么就会多次减1，直到为0。然后 block 状态的线程可以再次获取锁.

该关键字在编译成 class 文件后可以看到对应的语句是 monitorEnter 与 monitorExit，实际上是对应到了 OS 的**互斥量**。而1.6之前这个关键字性能不佳，所以在1.6之后引入了一系列的优化，包括**偏向锁**，轻量级锁，以及**自适应自旋锁**等等，其实核心理念都是根据当前的并发程度去尽量避免直接用到 OS 的互斥量去完成同步操作，因为这样会导致线程在用户态与内核态之间来回切换，比较重。 

### CAS 的实现原理

CAS：比较后替换，由硬件提供的原语保证其操作原子性。 CAS一般会存在ABA问题，本质上是因为数据可回环，因此解决掉数据回环问题即可，加上版本号，或者对应时间戳之类的。 CAS一般与volatile关键字一起去实现无锁化的同步操作，可以有效的提升一些场景下的性能，比如在concurrentHashMap的元节点控制上就是用的CAS去做替换。 但是CAS+volatile却不适合做高并发场景下的同步，主要原因是因为底层走的MESI协议，以及CAS通常情况下会伴随着自旋，在高并发情况下，自旋基本很难完成更新值的操作，反而白白浪费CPU资源

### ConcurrentHashMap 实现线程安全的底层原理

1.8以前使用的是分段锁技术，即将一个大数组分成多个小数组进行分段加锁,一个数组一个锁。在1.8之后,优化了细粒度,对数组的每个元素进行CAS,假设,多个线程同时操作Map但不是Map中的同一个数组,那么是没有关系的.如果是多个线程同时put操作Map中的一个数组,那么只有一个会成功,其他都会失败,此时需要基于链表或红黑树来处理,使用synchronized对当前数组加锁,然后进行操作.所以只要不是同时操作同一个位置的元素就不会触发同步的串行化操作,性能不会受影响.

### JDK 中的 AOS 理解

AQS有两种功能：独占和共享。 独占锁，每次只能有一个线程持有锁，ReentrantLock就是以独占方式实现的互斥锁。 共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantLock。 AQS队列内部维护的是一个FIFO的双向链表。 ReentrantLock内部类Sync继承自AQS，Sync有两个具体实现类，就是公平锁和非公平锁。 NofairSync非公平锁，存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁。 FairSync公平锁，表示所有线程严格按照FIFO来获取锁

### 线程池

#### 线程池的核心配置参数和底层工作原理

线程池核心参数：

- corePoolSize ：核心线程数
- maximumPoolSize：最大线程数
- keepAliveTime: 线程空闲时间
- blockingQueue ：等待队列

线程池初始时是没有线程的，但是可以在初始化线程池的时候设置一开始就创建几条线程在池子里。首先任务过来会去判断当前线程池里面的线程数是否大于核心线程数，如果小于则新建线程执行任务。执行完任务后的线程会去阻塞队列等待任务队列中有任务到来。如果任务过来发现当前线程池里面的线程数等于核心线程数，就将任务放在任务队列中，等待有线程来处理。如果任务队列放满了，就去判断当前线程池里面的线程数是否小于最大线程数，如果小于就创建线程执行任务，执行完毕后如果没有任务积压，线程大部分处于空闲状态，超过了 keepAliveTime，那么就会销毁线程，维持线程数在核心线程数；如果此时线程数等于最大线程数，就执行拒绝策略，抛异常或者是其他处理。

拒绝策略：

- AbortPolicy                      抛异常
- DiscardPolicy                  直接丢弃任务
- DiscardOldestPolicy      丢弃旧任务
- CallerRunsPolicy            由调用者处理

#### 线程中使用无界阻塞队列会出现什么问题



#### 线程池的队列满了之后会出现什么问题



#### 服务器宕机，线程池的阻塞队列中的请求怎么办



## Concurrent Tools

